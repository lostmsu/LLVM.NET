using System;

using LLVM;
using LLVM.Interop;
using LLVM.NativeLibrary;

class Random
{
	// we need to declare delegate type for our sample function
	delegate int IntFunc();

	static void Main()
	{
		// Loads native LLVM library. Without this call you must manually provide an appropriate
		// (32- or 64-bit)version of LLVM library in %PATH% or in application's directory.
		// For the current version of wrapper, file must be named "LLVM-3.1" without quotes.
		// Note: file must have no ".dll" extension!
		LLVMDLL.Load();
		// this call instructs LLVM to prepare itself to generate native code for
		// current processor architecture
		Target.InitializeNative();

		var context = Context.Global;
		// LLVM needs a module to contain code even if we use JIT
		var container = new Module("mymodule", context);
		// create an instance of JIT engine
		var jit = new ExecutionEngine(container);

		var i32 = IntegerType.GetInt32(context);
		var functionType = new FunctionType(i32);
		var function = container.CreateFunction("myrandom", functionType);
		function.CallingConvention = CallingConvention.Fast;

		// function consists of blocks
		var codeBlock = new Block("codeBlock", context, function);
		// LLVM IR is generated in block by this class instance
		var gen = new InstructionBuilder(context, codeBlock);
		// generate a return instruction
		gen.Return(i32.Constant(42, true));

		// ClrInterop provides interoperability for the code, generated by LLVM
		var interop = new ClrInterop(jit);
		// This line builds managed to native function wrapper. It deals with calling conventions.
		var managedDelegate = interop.GetDelegate<IntFunc>(function, container);
		var randomValue = managedDelegate.Invoke();
		Console.WriteLine(randomValue);
	}
}